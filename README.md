# EmbOS
__EmbOS__ - Простая минималистичная многопоточная операционная система для обучения, написанная на языке си и ассемблера (at&t) для архитектуры х64-86, ОС работает без использования механизма трансляции адресов (без виртуальной памяти) всегда работает на нулевом уровне привилегий с использованием системных вызовов, все программы непосредственно встроены в ядро и являются отдельными потоками, способная компилироваться для O2/O3.

Является второй ОС из серии руководств по программированию операционных систем (дружелюбна к новичкам в программировании). В процессе чтения руководства вы дальше продолжите знакомиться с архитектурой процессора x64-86, перейдёте уже к знакомству работы процессора в защищенном режиме вкратце узнаете о спецификации мультизагрузки-1, познакомитесь с такими компонентами процессора как: программируемый контроллер прерываний (i8259), программируемый таймер (i8254), познакомитесь с протоколом UART и напишите свой первый драйвер (rs232)

Так же научитесь правильной обработки прерываний, обработке системных вызовов и вложенных системных вызовов. Узнаете о работе потоков, напишите простой вытесняющий планировщик, распределитель памяти, реализуете свои собственные потоки, мьютексы, и условные переменные (condvar) разработаете их практически с полным соответствием стандарта POSIX и свою первую libc (на том уровне на котором это будет позволять микроядро ос) и научитесь использовать эмулятор qemu для отладки ваших собственных ос.

 ![image](./screenshots/diff_threads.png)

__в конечном итоге, код для вашей собсвенной микроос (слева), станет практический индентичным любой посикс совместимой ос(справа)__

В данной части используется максимально простые и наивные алгоритмы, после прочтения вы с уверенностью сможете писать свои собственные многопоточные микроос по аналогии для различных архитектур (обычно в плане переключение контекста пользователя другие архитектуры проще, чем x64-86) но правда все еще для одногопроцессора(ядра).

![image](./screenshots/log-ex.png)
__если вы новичок в системной программировании, то вывод на стандартный поток ввода-вывода даст вам информацию что же на самом деле происходит под капотом таких функций как gets, thread_sched и т.д в реальных ос (в реальных ос системные вызовы и действия меняются в зависимости от ос)__

Вторая часть руководства является подготовительной частью, перед третьей. В которой вы уже напишите полноценную, но все еще простую unix подобную ос (аналог unix v6).

 __P.S :: отсутствие руководства в папке /doc репозитория, означает что я работаю над реализациями других микро ос для следующих частей руководств. Как оказалось, написание самих микро ос напомного проще чем руководств.__  

 ## Demo
 ![image](./screenshots/demo.gif)

## Установка зависимостей.
ОС разрабатывалась в unix подобной среде с использованием компилятора (cc, as, ld, make), и я так же предпологаю что вы будете использовать такое же окружение (если вы используете такое окружения как windows, то самое время его поменять на что-то другое, а иначе вы будете вставлять себе с большой вероятности палки в колеса по непонятным вам причинам) в некоторых заголовочных файлах я использовал встроенные функции компилятора cc (__bultin_va_list и другие) по этому настоятельно рекомендую использовать компилятор от gnu.

```bash
# пример установки в среде debian / unix
sudo apt install qemu  # непосредственно сам эмулятор

# необходимый набор инструментов для сборки
# обычно уже присуствует в системе
sudo apt install gcс
sudo apt install make
```

## Структура проекта.
Для удобства изучения исходных кодов и так как ос вместе с ее пользовательскими программи являются одним целым, я не стал все заголовочные файлы хранить в ./inc, а логически их размещал в разных директориях.
```
  -debug
    исходный и заголовочный файл необходимый для отладки (вывода в qemu)
  -doc
    обучающее руководство.
  -driver
    исходный и заголовочный файл драйвера UART(rs232)
  -inc
    заголовочный файлы похожие как в libc только в менее в полном объеме,
    и файлы для обвертки над системыми вызовами для пользовательского кода
    (такие как threads, unistd)
  -init
    исходные файлы инициализации пользовательских крмманд и оболочки (потоков)
    точнее их простую абстракцию, все же встроенно уже в ядро. все файлы имеющие
    расширения *.c автоматичски копилируются при сборке проекта.
  -klib
    заголовочные и исходные файлы, каких-то общих используемых алгоритмов
    время прошедшее с момента запуска(кольцевой буфер, список и т.д)
  -mem
    заголовочные и исходные файлы распределителя памяти.
  -startup
    ассемблерный код который соответствует спецификации мультизагрузки 1,
    настраивает стек и запускает функции main ядра
  -sys
    заголовочные и исходные коды которые относятьсяне непосредственно к компонентам процессора,
    глобальная дескрипторная таблица, i8254(pit), i8259(pic) и так далее
  -system
    заголовочные и исходные файлы которые относяться непосредственно к ядру системы 
    (системные вызовы, потоки, планировщик ...)

  main.c      - точка входа в ядро ос.
  linker.lds  - скрипт линковщика.
```

## Компиляция и запуск.
Как и во всех моих руководствах, компиляция, запуск и перекомпиляция со своми тестовыми утилитами всегда проста. (все для удосбтва обучения)

```bash
make      # компиляция проекта
make qemu # запуск ос в эмулятора
```

## Интерфейс ОС.
__EmbOS__ - не графическая ОС, в принципе, как и все другие ОС из других частей. В данной ОС оболочка коммандной строки встроена непосредственно в ядро ОС, каждая комманда - это отдельный запущенный поток, оболочка поддерживает опернд '__&&__'.

Так как ОС используется для связи с внешним миром UART (rs232) то чтобы увидеть вывод в qemu, используйте сочетания клавишь ctr+alt+3, или выберите из меню view-seial0

```bash
# для примера, было реализовано несколько комманд
# поведение такое же как и в аналогичных командах unix
uptime          # файл init/cmd_uptime.c
uname           # файл init/cmd_uname.c
echo    [arg..] # файл init/cmd_echo.c
sleep   NUMBER  # файл init/cmd_sleep.c
help

# несколько примеров работы с потоками
thread-example0 # файл init/cmd_example0.c
thread-example1 # файл init/cmd_example1.c

# тестовая команда вызывающая исключение "неверный опкод"
ud2             # файл init/cmd_ud2.c

# код из примера что ниже
example         # файл init/cmd_example.c
```

## Создание пользовательских программ(комманд).
ОС создавалась впервую очередь с целью познакомить вас с работой потоков, то и каждая команда представляет собой отдельный поток. Из-за ограничение самой ос, что все программы встроенны непосредственно в ядро, для этой цели я рекомендую вам следующую структуру.

__1. Создайте исходный файл вашей команды в папке ./init__
```c
void*
own_command(void *arg)
{
  ...
}
```
__2. В файле ./init/shell_init.c__
```c

/* чтобы не размножать заголовочные файлы, и не получать предупреждения от компилятора */
extern void* own_command(void* arg);
...
void
shell_init(void)
{
  ...
  shell_register_command("имя вашей команды", own_command);
}

```
__3. Пересоберите проект и запустите, если сделано все верно, вы сможете вызвать свою команду из консоли.__ 
```bash
make && make qemu
```

## Пример.
Cоздаете файл в папке init с вашей коммандой, например cmd_example.c

__p.s:__ обратите внимание на то, как в конечном итоге будет выглядит код для вашей ос, этим самым я стараюсь вас дисциплировать и писать код красиво, приближенно к окружению unix (в следущай части уже будет реализовано в полном объеме) во первых просто для того, если вы знакомы с окружением си и unix вам было легко вникуть, а второе это лучше чем в некоторых туториалах наименование функций CreateThread(...) с огромным количествам параметров, что в итоге код становиться не красивым (хотя именно так реализовано всё в виндовс :p, выглядит и писать системные программы на си под неё просто ужасно)
```c
 #include <stdio.h>
 #include <stdlib.h>
 #include <thread.h>
 #include <unistd.h>

 static void*
 thread_example(void *arg)
 {
   (void) arg;

   printf("thread example\n");
   sleep(2);
   printf("thread end\n");

   return (void*) EXIT_SUCCESS;
 }

 void*
 cmd_example(void *arg)
 {
  (void) arg;
  
  struct thread *t1;
  thread_create(&t1, "EXAMPLE THREAD", &thread_example, NULL);

  return (void*) EXIT_SUCCESS;
 }

```
После чего открываете файл init/shell_init.c
```c
extern void* cmd_example(void *arg);
...
void
shell_init(void)
{
  ...
  shell_register_command("example", cmd_example);
}
```
## Результат работы
![image](./screenshots/example.gif)